package tasks.algorithm;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

/**
 * Задача: Есть штанга. Рассчитайте, какой максимальный вес можно поднять с заданным набором блинов.
 * Вес правой части должен быть равен весу левой части. Гриф считаем невесомым.
 * <p>
 * На входе: [1,2,3,6] На выходе: 12. Пояснение: {1,2,3} и {6}
 * На входе: [1,2,3,4,5,6] На выходе: 20. Пояснение: {2,3,5} и {4,6}. Блин {1} нацепить не получится - потеря равновесия.
 * На входе: [1,2] На выходе: 0 Пояснение: нацепить без потери равновесия это нельзя.
 * На входе: [3,4,3,3,2]. На выходе: 12. Пояснение: {3,3} и {4,2}. Оставшийся {3} девать некуда.
 * <p>
 * Ограничения:
 * Вес блина от 0 до 20.
 * Количество блинов: от 1 до 1000.
 * Суммарный вес целого набора не более 10000.
 *
 * @author Aleksei Sapozhnikov (vermucht@gmail.com)
 * @version 0.1
 * @since 0.1
 */
public class DynamicProgMaxWeightTwoEqualSubArrays {

    /**
     * Нам нужно разделить набор на непересекающиеся поднаборы. Для этого будем использовать динамическое
     * программирование со следующими рассуждениями.
     * <p>
     * Пусть A и B - это сумммарный вес блинов в двух наборах.
     * Пусть d = A - B - это разность этих наборов по массе.
     * Пусть s = (A + B) - суммарный вес, который образуют эти наборы.
     * Тогда наша задача сводится к нахождению max(s) при d = 0.
     * <p>
     * Решение: строим таблицу (карту) с парами d-->s. То есть, значение суммы при заданной разности d.
     * Ставим начальное значение (0,0) - у нас два пустых набора A и B с нулевой разностью и массой.
     * <p>
     * Затем мы проходимся по всем элементам массива чисел. Поскольку при анализе каждого числа мы проходимся
     * по карте (d-->s) и в ней же меняем значения, приходится создать копию этой карты,
     * чтобы избежать ConcurrentModificationException.
     * <p>
     * Взяв один элемент, мы проходимся с ним по имеющимся значениям разности d в карте.
     * Смотрим: вот у нас есть исходное состояние, где при такой-то разности массивов d имеем такую-то сумму s.
     * А какая разность массивов и суммарный вес будут, если к этой системе добавить наш элемент? А добавить его
     * можно по-разному: в подмассив А иили в подмассив B. При анализе мы выбираем вариант, где будет максимальный
     * вес и записываем именно его.
     * Логика проверки добавления элемента и записи результата вынесена в метод
     * {@link DynamicProgMaxWeightTwoEqualSubArrays#tryAddElementToEachSubset(int, Map, Map.Entry)}.
     * <p>
     * Когда мы проанализировали один элемент, мы записали значения в копию нашей карты d-->s. Осталось обновить
     * нашу карту d-->s (просто присваиваем ее переменной ссылку на копию). Все, операция с одним элементом
     * завершена.
     * <p>
     * Осталось повторить все эти действия для каждого элемента - и мы получим таблицу d-->max(s). Исходная задача
     * сводилась к тому, чтобы найти максимальный вес при одинаковых суммах в A и B. Тогда ответ - значение
     * max(s) при d == 0.
     * <p>
     * {@see https://stackoverflow.com/questions/52244676/given-an-array-you-have-to-find-the-max-possible-two-equal-sum}
     * {@see https://stackoverflow.com/questions/52270073/clarification-of-answer-find-the-max-possible-two-equal-sum-in-a-set}
     * {@see http://discuss.codingblocks.com/t/algorithm-to-find-two-subsets-of-an-array-which-are-maximum-equal/1878}
     *
     * @param numbers Заданный массив чисел.
     * @return Максимальная сумма, которую можно получить, создав два непересекающихся подмножества, у которых
     * сумма элементов одинакова.
     */
    public int maxSum(int[] numbers) {
        Map<Integer, Integer> diffSum = new HashMap<>();
        diffSum.put(0, 0);
        for (int element : numbers) {
            Map<Integer, Integer> diffSumCopy = new HashMap<>(diffSum);
            for (Map.Entry<Integer, Integer> entry : diffSum.entrySet()) {
                this.tryAddElementToEachSubset(element, diffSumCopy, entry);
            }
            diffSum = diffSumCopy;
        }
        return diffSum.get(0);
    }

    /**
     * Метод применяется для каждого заданного элемента исходного массива весов.
     * <p>
     * Метод Проводит анализ для текущего значения d разности подмассивов A и B и соответствующей этой d
     * на данный момент максимальной суммы s.
     * <p>
     * Анализируем: а если добавить текущий элемент в массив А? А если в B? А если не добавлять?
     * Обозначим вес элемента за e. Тогда новая сумма наборов s2 и новая разность d2 получаются в разных случаях:
     * 1) если добавляем в A: s2 = s + e; d2 = (A + e) - B = d + e
     * 2) если добавляем в B: s2 = s + e; d2 = A - (B + e) = d - e
     * 3) если не добавляем никуда: s2 = s; d2 = d;
     * <p>
     * В случае 3) анализировать нечего, поскольку мы ничего не меняем.
     * <p>
     * В Случаях 1) и 2) работаем по одной схеме: вычисляем новое значение разности d. Поскольку нам неважно,
     * массив A по весу больше B или наоборот, мы берем d2 = abs(d). Ну, а сумма известна: s2 = s + e.
     * Если для получившейся d2 в карте уже существует посчитанное для набора предыдущих элементов значение,
     * мы сравниваем нашу s2 с суммой из карты и берем наибольшую. Ведь мы ищем максимальную сумму. Если же значение
     * суммы отсутствует в карте, берем его как == 0 - меньше некуда.
     * Сравнив суммы, выбрав наибольшую, мы кладем ее значение в карту.
     */
    private void tryAddElementToEachSubset(int element, Map<Integer, Integer> diffSum, Map.Entry<Integer, Integer> entry) {
        int diff = entry.getKey();
        int sum = entry.getValue();
        int sumWithElement = sum + element;
        Stream.of(diff + element, diff - element).forEach((newDiff) -> {
                    int diffWithElt = Math.abs(newDiff);
                    int currentMaxSum = diffSum.getOrDefault(diffWithElt, 0);
                    int maxSum = Math.max(currentMaxSum, sumWithElement);
                    diffSum.put(diffWithElt, maxSum);
                }
        );
    }

}
