package tasks.sort;


import java.util.Arrays;

/**
 * Алгоритм быстрой сортировки.
 * <p>
 * 1. Выбрать опорный элемент (случайный, средний).
 * 2. Разделить массив на два подмассива: элементы меньше опорного и элементы, равные опорному или больше него.
 * 3. Рекурсивно применить сортировку к двум подмассивам.
 * 4. Разбиение на подмассивы идет до тех пор, пока в полученном массиве не останется лишь один элемент.
 *
 * @author Aleksei Sapozhnikov (vermucht@gmail.com)
 * @version 0.1
 * @since 0.1
 */
public class QuickSort {

    /**
     * Рекурсивный метод сортировки.
     * <p>
     * Вначале применяется ко всему массиву, а затем - к получившимся после разделения
     * по опорному элементу подмассивам.
     * <p>
     * Вначале проверяются условия выхода:
     * 1) Если массив пуст - выход.
     * 2) Если подмассив имеет длину <=1 - тоже выход. Длина подмассива определяется
     * по позцияим начала и конца: если start >= end - выход.
     * <p>
     * Выбираем опорный элемент в центре массива.
     * <p>
     * Далее идем по подмассиву с двух сторон: с начала и с конца, до первого "не там стоящего"
     * элемента. Элемент "стоит не там" в двх случаях:
     * 1) он слева от базового и больше него
     * 2) он справа от базового и меньше него.
     * <p>
     * Найдя такие элементы, меняем их между собой.
     * В итоге после прохода:
     * слева - подмассив с элементами меньше опорного;
     * справа - подмассив с элементами больше опорного.
     * <p>
     * Наконец, осталось просто вызвать рекурсивно метод
     * на полученных подмассивах - и там пройдет то же самое.
     * <p>
     * На практике рекомендуют при маленьком размере массива (скажем, <=8 элементов)
     * переходить на другой алгоритм для эффективности (например, тем же пузырьком).
     *
     * @param array Сортируемый массив.
     * @param start Начало сортируемого подмассива.
     * @param end   Конец сортируемого подмассива.
     */
    private static void quickSort(int[] array, int start, int end) {
        if (array.length == 0 || start >= end) {
            return;
        }
        int middle = start + (end - start) / 2;
        int baseElt = array[middle];
        int i = start;
        int j = end;
        while (i <= j) {
            while (array[i] < baseElt) {
                i++;
            }
            while (array[j] > baseElt) {
                j--;
            }
            if (i <= j) {
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }
        quickSort(array, start, j);
        quickSort(array, i, end);
    }

    /**
     * Начальный метод для сортировки. Запускает массив целиком.
     *
     * @param array Массив для сортировки.
     * @return Тот же самый массив после сортировки (для простоты написания тестов).
     */
    public int[] quickSort(int[] array) {
        quickSort(array, 0, array.length - 1);
        return array;
    }
}
